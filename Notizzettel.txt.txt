Modern C++

Peter Loos

Guten Morgen :)

https://github.com/pelocpp

a) VS Studio

b) Github

=====================================================

Übungen: Ab groob 15.30  

=====================================================

Überblick
---------

Performance // Echtzeit  // "Statisch vs. Dynamisch"

CRTP

Smart Pointer

Multithreading

Templates

Funktoren

Lambdas

emplace

=====================================================

Move-Semantik:

:==:  ...F80  // temp. Objekt // wird freigegeben
:==:  ...1B0  // wird später freigegeben

versus

:==:  ...0D0  // 


:==:  ...EA0


==========================================

Verwenden Sie Container der STL.

Dyn. Speicherverwaltung:   reserve: Initialer Speicher

===========================================

LittleData
BigData:   BigData => Typkonvertierungs-Operator: LittleData

operator LittleData

===========================================

Normale Funktionen

Template Funktionen

Generische Funktionen

===========================================

Lambda's

std::memset

C++ Strings library Null-terminated byte strings 
Defined in header <cstring>

void* memset( void* dest, int ch, std::size_t count );

Hochperformant:

Intel CPU:

Lambda's:

Lambda-Funktion

Ein Lambda ist ein OBJEKT !!!!!!!!

=============================================

Wie sortiere ich einen Baum ???

a) Ich benötige 2 Iteratoren

b) Es gibt unterschiedliche Iteratoren-Typen:

i) Forward-Iterator

X) Random-Access Iterator:
zb einen Zugriff auf ein Element an der Stelle "Index"
00007FF717931D98  mov         edx,dword ptr [n1]  
00007FF717931D9E  mov         rcx,qword ptr [__imp_std::cout (07FF717C1F6A0h)]  
00007FF717931DA5  call        qword ptr [__imp_std::basic_ostream<char,std::char_traits<char> >::operator<< (07FF717C1F7C0h)]  
00007FF717931DAB  lea         rdx,[string " mit " (07FF717B26030h)]  
00007FF717931DB2  mov         rcx,rax  
00007FF717931DB5  call        std::operator<<<std::char_traits<char> > (07FF7178D6459h)  

00007FF717931DBA  mov         qword ptr [rbp+0C0h],rax  
00007FF717931DC1  mov         edx,dword ptr [n2]  
00007FF717931DC7  mov         rcx,qword ptr [rbp+0C0h]  

vs.

00007FF6BC73282E  mov         qword ptr [rbp+0C0h],rax  
00007FF6BC732835  mov         rax,qword ptr [n2]  
00007FF6BC73283C  mov         eax,dword ptr [rax]  
00007FF6BC73283E  mov         dword ptr [rbp+0C8h],eax  
00007FF6BC732844  mov         edx,dword ptr [rbp+0C8h]  
00007FF6BC73284A  mov         rcx,qword ptr [rbp+0C0h]  

00007FF717931DCE  call        qword ptr [__imp_std::basic_ostream<char,std::char_traits<char> >::operator<< (07FF717C1F7C0h)]  
00007FF717931DD4  mov         qword ptr [rbp+0C8h],rax  
00007FF717931DDB  lea         rdx,[std::endl<char,std::char_traits<char> > (07FF7178DC03Eh)]  
00007FF717931DE2  mov         rcx,qword ptr [rbp+0C8h]  
00007FF717931DE9  call        qword ptr [__imp_std::basic_ostream<

// ====================================================

C++

== Objekt-Orientiert:               Bjarne Stroustrup // C with Classes

== Prozedural

== Generische Programmierung        Alexander Stepanov

== STL: Rein generische Bibliothek

// ====================================================

Übungen:

a) Move-Semantik:  Aufgabe 1

b) Lambda Funktionen: :  Aufgabe 1

c) Generische Lambda Funktionen: :  Aufgabe 1

Empty Project :)

=======================================================================

Smart Pointer:
--------------

Worum geht es ???

int* ip;

ip = new <========  Speicher  // Heap

..........

delete !!!

i)  delete ip;      Scalar delete // new Point;

ii) delete[] ip;    Non-Scalar delete:  new Point [n]; 

Frage:  ii) ===>  delete ip;

UB:  undefined behaviour 

Wer ruft delete auf ???

"Dieses wird halt vergessen"   ==> Leak

Ja, das OS verwaltet den Speicher (  Prozessen )

new / delete: Im Kontext eines Prozesses

Idee:

a) Pointer ===>  Hüllenklasse / Hüllenobjekt

b) OO / Klassen:   Konstruktoren / Destruktoren

c) Wann wird ein Destruktor aufgerufen:  deterministisch !!!

   i) Global
   ii) Lokal  ( Stack )  <======== Am Ende des Blocks wird der Destruktor aufgerufen
   iii) Dynamisch ( new / delete )

d) Ansatz:  

   i) Man legen den Pointer in einem Hüllenobjekt ab
   ii) Man platziere den Aufruf des delete im Destruktor

   ==> Lokal:  der delete wird am Ende des Blocks deterministisch aufgerufen.

e) Optionen: Hüllenobjekte sind über Funktionsgrenzen transportierbar.


A) Realisierung:  auto_ptr:   deprecated

B) 3 Smart-Pointer:

   std::unique_ptr
   std::shared_ptr
   std::weak_ptr

Unterschiedliche Strategien:

std::unique_ptr:

  Zu einem Zeitpunkt im Programm kann es NUR EINEN BESITZER eines
  std::unique_ptr Objekts geben.

std::shared_ptr

  Zu einem Zeitpunkt im Programm kann es MEHRERE BESITZER eines
  std::shared_ptr Objekts geben.

  std::weak_ptr gehört zum Repertoire des std::shared_ptr.




  ==============================================

  Copy - Elision:

  to elide ==> auslassen, weglassen, ....

  Optimierungs-Technik:

    ==============================================

a) Habe ein std::shared_ptr Objekt angelegt!

b) this

c) Hmn, kann ich den this-Zeiger weiterreichen ... Pointer

    Zu hinterfragen ... eher nein

d) What's the problem: Ich reiche ein std::shared_ptr(this) weiter

   SO GEHT DAS NICHT

e) Da gibt es eine UNterstützung:

   std::shared_from_this

Beispiel:

class Observer : public std::enable_shared_from_this<Observer> {

CRTP ==>  Curious

Dann geht folgendes innerhald der Klasse Observer:

std::shared_ptr<Observer> me{ shared_from_this() };

Das ist quasi ein Shared_Pointer von THIS

STOLPERFALLE // VORSICHT !!!!!!!!!!!!!!!!!!!!

Hmm: Ich legen den 'me'  // std::shared_ptr<Observer> 

     gleich im Konstruktor der Klasse Observer an.

     NIEEEEEEEEEEEEEEEEEEEEEEEEEEEEMALS

     Den dazugehörigen Control Block gibt es noch nicht.

===============================================================

Es gibt noch ein kleines Problem:

Der std::shared_ptr funktioniert nicht immer :-(((((((((

===============================================================

Der std::shared_ptr ist in der Regel nur mit
dem std::weak_ptr zu gebrauchen.

a) Technik des std::weak_ptr
b) Wozu, wann, ...

===============================================================

Moral von dieser Geschichte:

a) Nicht ausschließlich std::shared_ptr verwenden.

b) Verwenden, wenn das Objekt BENÖTIGT wird.

c) Andere Programmteile, die das Objekt nur "passiv" verwenden wollen:

   std::weak_ptr ausgestattet werden.

d) SW: Gewisse Flexibilität vorhanden sein:

   Zugang zum Objekt via lock.
   
   Rückgabe == nullptr: Don't care.

BEISPIEL:

Observer - Pattern:

a) Source: Diese wird beobachtet 
   
    (( Liste von Beobachtern ))

b) Beobachter:  Clients, die sich für Änderungen an der Source interessieren.

i)  Prinzipiell: ALLE Objekte werden via shared_ptr angelegt.

ii) Wie werden Clients der Source bekannt gemacht:

    Via weak_ptr: lock // nullptr

====================================================

Fazit:  "Go for Smart Pointer"

====================================================

Initialisierung:

========>  Überarbeitung.

========>  Kein Bruch zu alter SW.

() :  Methodenaufruf
{} :  Vorbelegung

Strikt: 

Uniform Initialization // Brace Initialization:

{}:  Initialisierung  / Gilt auch für KONSTRUKTOR Aufruf
() : Methodenaufruf

Hübscher // Kleine Ergänzungen.

=======================================================

std::vector:            Daten liegen auf dem Heap  (new)

std::initializer_list:  Daten liegen auf dem Stack  (NO new)

Achtung:

std::initializer_list  ist kein "vollwertiger" STL-Container

Hilfscontainer

Light-Weigt Container

==========================================================

std::vector:            Daten liegen auf dem Heap  (new)
std::initializer_list:  Daten liegen auf dem Stack (NO new)

std::string:            Daten liegen auf dem Heap  (new)
std::string_view:       Daten liegen nicht auf dem Heap (NO new)

std::array:             Daten liegen auf dem Heap oder Stack
std::span:              Daten sind bereits vorhanden

Utility-Klassen

==========================================================

   std::tuple:

   Ein Tuple ist wie eine Struct für Schreibfaule

==========================================================

Variant  // Any

std::variant

Ähnlich - aber nur - zu union:

Ist ein Objekt, dass Daten unterschiedlichen Typs enthalten kann.
Zu einem Zeitpunkt nur eine Variable.

Beispiel:

Excel / Sheets:  Zelle / Cell:  Number, string, Date, double, 

Game Programming:  Board:  Figure:  Pro Board Slot eine andere Figur.

=================================================================

Betrachung von Datentypen:

Reflection   // Java oder C#

Type Traits  // Typ Spuren 

Analyse von Datentypen.

Zur Übersetzungs- oder zur Laufzeit ????????????????????

A) Geht zur Laufzeit -- mit Konsequenzen

B) Geht zur Übersetzungszeit:  mit constexpr


=================================================================

Aufgaben zu Smart Pointer: 1, 2 und 4

Aufgaben zu STL-Algorithmen: Aufgabe 2

Fibonacci:

std::vector <int> zahlen (20);   // Vektor hat die Länge 20

std::generate ( zahlen.begin(), zahlen.end(),  [] () {   }     )  ;

=================================================================

constexpr

Templates

===============================

friend:

Ein bissweilen kritisiertes Feature in C++:

Es ist möglich,

Klassen, globale Funktionen

durch eine ANDERE Klasse zum Freund zu ernennen.

===>

Dadurch haben diese Klassen, diese globale Funktionen
Zugriff auf die privaten Daten der Klasse, die die Freundschaft erteilt hat.


Self-Invoking Lambda

=============================================================================

Konstanten // Literale 

123

1234.456F

1234l   long

234ll   long long

100_km  kilometer

50_kg   kilogramm          NICHT im LEXIKON von C/C++ enthalten

==> int / long

12345_rgb  ;  Farbe RGB 

0x12345_rgb  ;  Farbe RGB 

"10:05:30"_time

==> Klasse Color


Technologische Konstanten

UDL User Defined Literal // Benutzerdefinierte Literale

Umsetzung:

  operator ""   UND Syntax Ergänzung für das Suffix (  _kg,  _km, _rgb )

Erwartet jeweils den "größten" Datentyp:

long long

long double

char*

========================================================

Variadische Templates

a) Debugger

b) Cpp Insights

==>  Vielen Funktionen:  Code Bloat 

Whyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy ?


====================================================

...   Ellipses

Parameter Pack

func (TArgs ... args)

func (1, 2, 3)

Was passiert: Auspacken:  

args ...   ==> Komma-getrennte Liste erzeugt.

C++:  std::initializer_list:   { 1, 2, 3 }

Möchte auf jedes Elements eines Packs eine Funktion anwenden.

Es gibt immer eine Lösung.

// =================================================

Frage:

Wie implementiere ich die Methoden eines Klassen Template ???

NICHT wie die einer normalen Klasse !!!

Ist hier beschrieben:

https://github.com/pelocpp/cpp_modern_examples/blob/master/GeneralSnippets/TemplateClassBasics/TemplatesClassBasics.md

Das Inclusion Modell

Das Explicit Instantiation Modell


// =================================================


C++ und STL Algorithmen

back_inserter


// =================================================


Hash-Tabelle // Dictionary:

Java:  Hashmap   / Index ==> 

C++:   std::unordered_map

Was ist std::map:   Baum / Tree:  Sortiert

// =================================================

Was ist ein Callable ???

Invoke	std::invoke: "Uniformly invoking anything callable"

// =================================================

Übungsaufgaben:

Aufgaben zum Perfect Forwarding:   

   Aufgabe 2: Ausführungszeit einer Funktion


Aufgaben zu variadischen Templates:

   Aufgabe 1: Logische Operationen mit beliebig vielen Operanden

   Aufgabe 2: decltype und Type-Traits am Beispiel von sameType


Aufgaben zu Utility Klassen:

   Aufgabe 2	Visitor-Entwurfsmuster mit std::variant und std::visit

